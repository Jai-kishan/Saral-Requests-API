{"id":1688,"parentExerciseId":null,"name":"Binary Search","slug":"recursion__binary-search","sequenceNum":9000,"reviewType":"peer","solution":null,"content":"```ngMeta\r\nsubmissionType: url\r\n```\r\n## Binary Search\r\n\r\nHumei ek list mei koi element search karna hai. Ek example lete hai.\r\n\r\n```python\r\nto_find_list = [2, 5, 9, 12, 81, 23, 71, 28, 90, 67]\r\nto_find_element = 81\r\n```\r\n\r\nAb aise sochiye ki humein dekhna hai ki `to_find_element`, `to_find_list` mei hai ya nahi. Agar aap `to_find_list` ko do parts mei divide kar doge, toh kya aap yeh dekh paa rahe hai, ki agar `to_find_element` - `to_find_list` mei hai, toh woh inn dono mei se kisi part mei toh jaroor hoga.\r\n\r\nKyuki `to_find_list` mei 10 elements hai, toh dono parts ko 5-5 elements each milenge.\r\n\r\n```python\r\nfirst_part = [2 , 5, 9, 12, 81]\r\nsecond_part = [23, 71, 28, 90, 67]\r\n```\r\n\r\n`81` element jo humei search karna tha woh pehle list mei hai.\r\n\r\nToh agar aap dekhein toh\r\n\r\n`to_find_element` - `to_find_list` mei hoga agar woh uske dono mei se kisi part mei hai, nahi toh nahi hoga. Toh aap iss information ko use kar kar code likhein jo element ko search karta hai.\r\n\r\nDhyaan rakhein ki dheere dheere dono parts ya toh empty ho jayenge, ya usmei ek single element bachega jo `to_find_element` ke equal hoga.\r\n\r\n## Solution\r\n```python\r\ndef is_present_in_list(number_to_search, list_to_search):\r\n    length_of_list = len(list_to_search)\r\n\r\n    if length_of_list == 0:\r\n        return False\r\n\r\n    if length_of_list == 1:\r\n        # list_to_search[0] is the only element left in this list\r\n        if number_to_search == list_to_search[0]:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n    first_half_of_list = list_to_search[:length_of_list/2]\r\n    second_half_of_list = list_to_search[length_of_list/2:]\r\n\r\n    return is_present_in_list(number_to_search, first_half_of_list) or is_present_in_list(number_to_search, second_half_of_list)\r\n\r\nprint is_present_in_list(3, [3, 5, 7, 8, 4, 6, 2, 1, 9])\r\nprint is_present_in_list(10, [3, 5, 7, 8, 4, 6, 2, 1, 9])\r\n```\r\n\r\n## Dhyaan Rakhein\r\n```python\r\ndef is_present_in_list(number_to_search, list_to_search):\r\n    counter = 0\r\n    while (counter < len(list_to_search)):\r\n        if number_to_search == list_to_search[counter]:\r\n            return True\r\n        counter += 1\r\n\r\n    return False\r\n\r\nprint is_present_in_list(3, [3, 5, 7, 8, 4, 6, 2, 1, 9])\r\nprint is_present_in_list(10, [3, 5, 7, 8, 4, 6, 2, 1, 9])\r\n```\r\n\r\nuse kar kar abhi tak humne yeh code likha tha. Yeh kaafi efficient tareeka bhi hai. Par humne recursion wala tareeka apni understanding build karne ke liye hi kiya hai.\r\n","submissionType":"url","githubLink":"https://github.com/navgurukul/newton/tree/master/recursion/binary-search.md"}